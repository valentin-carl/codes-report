\section{SAND}\label{sec:SAND}

In this section, the earlier mentioned paper \textsc{sand} is examined
in more detail, providing a more detailed examination of its concepts
and their implementation in Nuclio.

\subsection{Concept}
\textsc{Sand}, authored by Akkus et al. \cite{akkus2018sand} addresses
similar limitations of conventional FaaS platforms as \textsc{Fusionize}, 
such as cascading cold starts or the overhead in remote function invocations,
but offers a different approach to tackle these problems. Through the introduction
of two pivotal techniques - application sandboxing and hierarchical message queuing,
the serverless computing system \textsc{sand} presented in the paper is able to achieve
superior performance in terms of lower latencies and enhanced resource efficiency
compared to other serverless platforms.

\subsubsection{Application Sandboxing}
Contrary to the common practice of isolating each function within a container in
serverless computing, \textsc{sand} implements isolation between applications.
Viewing an application as a sequence of multiple serverless functions, in \textsc{sand}
all functions of an application share a container, causing a weaker barrier between
functions of the same application and reducing the occurrence of cold starts.

\subsubsection{Hierarchical Message Queuing}
Another measure taken to facilitate internal function communication is the integration
of local message buses into applications. In common serverless computing systems, an
internal request is treated the same way as an external request, which means a request
from one function to another function in the same application must pass through the
full end-to-end function call path. Using a message bus in each application container
creates a shortcut for such requests, while also enabling asynchronous communication.
Instead of sending an internal function request to, for example, a global controller,
where each request passes through, in SAND an internal function request is sent to the
local message bus, remaining in the containers network. Although \textsc{Sand} also
introduces a global message bus as a fail-safe for message delivery, its implementation
was deemed non-essential to the core improvements and therefore not integrated into Nuclio.

\subsection{Implementation Overview}
To improve Nuclio, isolation between applications and local message buses were the main concepts to be implemented.

\subsubsection{Isolation Between Applications}
When Nuclio is running on Kubernetes, every function gets its own pod. To implement
application sandboxing we decided to isolate applications within pods, enabling multiple
functions to coexist within a single pod. This approach differs from the original
\textsc{Sand} implementation, which employed container-level sandboxing.  
%(why was container level sandboxing not an option?)

% maybe write about the manual deployment of functions in the same pod here


\subsubsection{Local Message Buses}
In Nuclio, when one function invokes another, whether within the same application or not,
the request follows a route that exits the current pod, passing through the dashboard.
Subsequently, the dashboard relays the request, directing it to enter another pod until
it reaches the target function for processing. However, leveraging pod-level sandboxing
in Nuclio presents an opportunity for optimization in communication between functions
of the same application.

To facilitate this optimization, we introduced local message buses, employing RabbitMQ
for implementation. Within each application node, a RabbitMQ server is deployed within
a container, featuring a dedicated queue for each function within the application. 
Instead of routing through the dashboard, internal requests are directed to the respective
queue of the target function within the local message bus. Given that the local message
bus resides within the same pod and network, communication latency is drastically reduced. 
To get the request from the message queue to the target function, another component from
\textsc{sand} is adapted - the grainworker.

Each function is assigned its own grainworker, tasked with monitoring its respective message
queue within the message bus. When a message appears in the queue, the associated grainworker
invokes the corresponding function. This means in summary an application sandbox in Nuclio
consists of a set of related functions, a grainworker for each function and a local messsage bus.

% add grainworker code for some extra pages - s t o n k s

% maybe a cute image of internal function communication here


\cite{akkus2018sand}